---
layout: post
title: 基于WIN32开发的YUV视频播放器
date: 2021-05-28 22:23:41 +0800
categories: C++
tag: C++
---

* content
{:toc}
导言：多媒体实验，一个基于WIN32平台开发的YUV视频播放器

## 设计要求

设计实现一个基于Win32的应用程序，包括如下功能**（满分100分）**：
1. 能够通过文件选择对话框选定两个视频文件。如果你使用OpenCV则可以选择常规的mp4或avi格式视频；如果你不使用OpenCV则建议载入yuv视频。我们在第十二周的实验代码压缩包“YUV视频播放的参考代码和YUV视频文件.zip”中包含了两个yuv视频文件，可供你使用。（占10分）
2. 能通过菜单选择任意一个视频进行**播放（占10分）**，具有**播放（占10分）**、**暂停（占10分）**、**停止功能（占10分）**。
3. 能通过菜单选择画中画效果，即在播放某一个视频时，同时把另外一个视频**缩小**至前一个视频画面的**右上角一同播放（占30分，其中缩小占10分、右上角占10分、一同播放占10分）**。在画中画播放过程中，任意视频如果**播放到结尾，该视频就从头重播**，周而复始**（占20分，其中若两个视频都能分别周而复始播放给20分，若只有一个可以则给10分）**。
4. 如果实现了额外的视频效果，则最多可以奖励**15分**。可以选择的视频效果：
   1)	可以用**鼠标拖拽**的方式**改变画中画的小视频的位置**（5分）
   2)	可以用鼠标在视频画面上**绘制线条**（5分）
   3)	可以将画中画的小视频改为**边缘图显示**（即显示其画面的边缘图而不是原图）（5分）



## 设计过程

本项目以老师在第12章的发布的 VideoProcDemo 项目为基础开发。

**1.**  **播放YUV视频（10分）。**老师的Demo已经可以进行YUV视频的播放，此项完成。

**2.**  **通过菜单选择任意一个视频进行播放（10分）。**第一反应是使用一个资源管理器进行文件的浏览和选择，于是选择了 OPENFILENAME 浏览文件，实现了通过菜单选择任意一个视频进行播放。

![image-20210528231519983](https://i.loli.net/2021/05/28/QB3yDlIhbcHC7SU.png)

**3.**  **播放、暂停和停止（30分）。**本项目中视频播放依靠的是定时器TIMER，在case WM_TIMER分支中对定时器事件进行处理，于是我使用两个变量实现对大小视频的状态记录。

![image-20210528231715728](https://i.loli.net/2021/05/28/KAWMyO71zUjDJmE.png)

​	当变量为1时，case WM_TIMER 分支就会继续播放视频，当变量为其他值时，则不会进行播放；点击暂停，变量会变为2，但此时不对变量n做出改动，当点击播放时，**变量变为1，实现视频的播放效果**，视频会继续播放，**实现暂停的效果**；点击停止，变量会变为3，此时设置变量n为0，当点击播放时，视频会从头播放，**实现停止的效果**。

![image-20210528231734890](https://i.loli.net/2021/05/28/C4YFOmZaMwQGWeo.png)

**4.**  **能通过菜单选择画中画效果，即在播放某一个视频时，同时把另外一个视频缩小至前一个视频画面的右上角一同播放（占30分，其中缩小占10分、右上角占10分、一同播放占10分）。**在 case WM_TIMER 分支中，首先对大视频进行渲染，在大视频渲染完成后，再对小视频进行渲染，**可以实现同时播放的效果**。对渲染函数 SetDIBitsToDevice 的传入变量进行修改，可以实现视频位置的改变，**实现右上角的效果**。缩小效果我采用隔行采样实现，即通过横向和纵向的各行采样，并将采样到的值存入长宽均为原视频一半的变量中，**实现图像的缩小**，比例为1：4。

**5.**  **在画中画播放过程中，任意视频如果播放到结尾，该视频就从头重播，周而复始（\*占20分，其中若两个视频都能分别周而复始播放给20分，若只有一个可以则给10分\*）。**在视频的播放过程中，全局变量n对当前播放视频的帧数进行计数，设置n超过一定大小时归零，**实现两个视频的循环播放**。

![image-20210528231746742](https://i.loli.net/2021/05/28/JMpsGafRmhlkn7P.png)

**6.**  **可以用鼠标拖拽的方式改变画中画的小视频的位置（5分）。**首先定义 currentxPos 和 currentyPos 来记录当前鼠标点击的x和y的坐标，当落点在小视频范围内时，拖拽鼠标，记录下移动的距离，并计算更新获得当前的 currentxPos 和 currentyPos ，下一帧就会在新的位置进行渲染，从而**实现拖拽改变小视频位置的效果**。

![image-20210528231757531](https://i.loli.net/2021/05/28/mzjo7c4U1VMaT6S.png)

![image-20210528231808203](https://i.loli.net/2021/05/28/o165D2qKLaNd8MC.png)

**7.**  **可以用鼠标在视频画面上绘制线条（5分）。**定义一个变量draw_mode，当点击开始绘制时，draw_mode变为1，通过 MoveToEx 和 LineTo 函数实现起点和终点之间的连线。由于视频播放时会使线条消失，于是我使用数组 startx、starty、endx、endy 记录下所有的起点和终点，在图片渲染时进行重绘，**实现在播放的视频上绘制线条**。

![image-20210528231817553](https://i.loli.net/2021/05/28/mOhxyQqi3tnkare.png)

![image-20210528231836715](https://i.loli.net/2021/05/28/gZB9EXmovlbxkRS.png)

**8.**  **可以将画中画的小视频改为边缘图显示（即显示其画面的边缘图而不是原图）（5分）。**使用老师在第九周实验中提供的平滑滤波卷积核，对图像进行平滑滤波处理。

![](https://i.loli.net/2021/05/28/gZB9EXmovlbxkRS.png)

将原图与处理过后的模糊图对应像素相减，**实现边缘图显示的效果**。

![image-20210528231855491](https://i.loli.net/2021/05/28/FoUquLVSJWgbIv4.png)



## 难点解析

在本次实验中，我遇到最难以处理的问题是**视频的缩小问题**。按照我原先的想法，在我进行隔行采样后，应该就能得到一个大小比为1：4的小视频，但是在实际的操作过程中，小视频显示出来的图像总是只显示一半，我调整了很多参数，要么显示上半部分，要么显示下半部分，就是无法完全显示

![image-20210528231906946](https://i.loli.net/2021/05/28/MsjFwhgqZ1lYXQB.png)

在尝试多次无果后，我采用了一种很取巧的解决办法，我将缓存下一帧的变量设置为：

![](https://i.loli.net/2021/05/28/MsjFwhgqZ1lYXQB.png)

  即IMAGE_HIGHT不除2，于是我得到了一个上半部分带有黑边的完整视频。

![img](https://i.loli.net/2021/05/28/6cTUFRVKS2ibxlG.jpg)

​	最后在**SetDIBitsToDevice函数中将传入的扫描线数量变量由IMAGE_HIGHT设置为IMAGE_HIGHT/2**，由于这个函数渲染图片时从底部进行扫描，于是将扫描线数量设置为一半后，上半部分的黑色部分消失，获得一个理想的缩小视频。



## 成果展示

Bilibili视频链接：[基于WIN32的画中画视频程序演示](https://www.bilibili.com/video/BV1F54y1V7Nm)



## 实验总结

​	通过这次实验，我对这学期所学的WIN32的程序开发有了更深的了解，同时也熟悉了YUV视频的结构和存储方式和对位图的处理，我非常高兴能在实践中利用所学知识。

​	在实验中，我也遇到了不少的困难，因为是初次接触WIN32的程序开发，很多地方还不太熟悉，但我还是努力克服了困难，最终完成了程序的开发。

​	纸上得来终觉浅，绝知此事要躬行。学习不能只拘泥于课本，还是要以实践为主。书本上学到的终究是理论，只有多实践，才能从不断的失败中汲取经验，从而获得进步。
